---
alwaysApply: true
---
## Code Style & Structure

### Backend (Node.js/Express)

#### File Organization
```
server.js                    # Main entry point, routes, middleware
services/
  â”œâ”€â”€ scheduler.js           # Core posting engine with cron
  â”œâ”€â”€ oauth.js               # OAuth flows for all platforms
  â”œâ”€â”€ database.js            # Centralized DB operations
  â”œâ”€â”€ ai.js                  # Claude caption generation
  â”œâ”€â”€ ai-image.js            # Stability AI image generation
  â”œâ”€â”€ cloudinary.js          # File upload management
  â”œâ”€â”€ billing.js             # Stripe integration
  â”œâ”€â”€ accounts.js            # Account management utilities
  â”œâ”€â”€ templates.js           # Template CRUD operations
  â””â”€â”€ [platform].js          # Platform-specific posting (linkedin.js, twitter.js, etc.)
config/
  â””â”€â”€ plans.js               # Billing plan definitions
migrations/
  â””â”€â”€ *.sql                  # Database migrations
```

#### Naming Conventions
- Use `camelCase` for variables and functions: `getUserCredentials`, `postToLinkedIn`
- Use `SCREAMING_SNAKE_CASE` for constants: `MAX_RETRIES`, `API_VERSION`
- Use descriptive names with auxiliary verbs: `isProcessing`, `hasExpired`, `canPost`
- Prefix async functions with action verbs: `async function fetchUser()`, `async function createPost()`

#### API Route Structure
```javascript
// Protected endpoint pattern
app.post('/api/endpoint', verifyAuth, async (req, res) => {
  try {
    const userId = req.user.id;
    
    // 1. Validate input
    if (!requiredField) {
      return res.status(400).json({ success: false, error: 'Missing field' });
    }
    
    // 2. Check usage limits
    const usageCheck = await checkUsage(userId, 'type');
    if (!usageCheck.allowed) {
      return res.status(402).json({ 
        success: false, 
        error: usageCheck.message,
        limitReached: true 
      });
    }
    
    // 3. Perform operation
    const result = await performOperation(data);
    
    // 4. Increment usage
    await incrementUsage(userId, 'type');
    
    // 5. Return success
    res.json({ success: true, data: result });
    
  } catch (error) {
    console.error('Error in /api/endpoint:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});
```

#### Service File Pattern (for new platforms)
```javascript
// services/newplatform.js

/**
 * Posts content to NewPlatform
 * @param {string} text - Post caption
 * @param {string} imageUrl - Optional image URL
 * @param {Object} credentials - OAuth credentials
 * @returns {Object} - { success, postId, error }
 */
async function postToNewPlatform(text, imageUrl, credentials) {
  try {
    // 1. Validate credentials
    if (!credentials.accessToken) {
      throw new Error('Missing access token');
    }
    
    // 2. Check token expiry and refresh if needed
    if (needsRefresh(credentials.token_expires_at)) {
      credentials.accessToken = await refreshToken(credentials.refreshToken);
    }
    
    // 3. Prepare request
    const postData = {
      text,
      ...(imageUrl && { media_url: imageUrl })
    };
    
    // 4. Make API call
    const response = await axios.post(
      'https://api.newplatform.com/v1/posts',
      postData,
      {
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`,
          'Content-Type': 'application/json'
        }
      }
    );
    
    // 5. Return result
    return {
      success: true,
      postId: response.data.id,
      platform: 'newplatform'
    };
    
  } catch (error) {
    console.error('NewPlatform posting error:', error.message);
    return {
      success: false,
      error: error.response?.data?.error || error.message,
      platform: 'newplatform'
    };
  }
}

module.exports = { postToNewPlatform };
```

#### OAuth Flow Pattern
```javascript
// 1. Initiate OAuth
app.get('/api/oauth/platform/authorize', verifyAuth, (req, res) => {
  const userId = req.user.id;
  
  // Generate PKCE code_verifier and code_challenge
  const codeVerifier = crypto.randomBytes(32).toString('hex');
  const codeChallenge = base64url(crypto.createHash('sha256').update(codeVerifier).digest());
  
  // Store verifier for callback
  sessionPkceStore.set(userId, { codeVerifier, timestamp: Date.now() });
  
  // Create encrypted state
  const state = encryptState(JSON.stringify({ userId, nonce: crypto.randomBytes(16).toString('hex') }));
  
  // Redirect to OAuth provider
  const authUrl = `https://oauth.platform.com/authorize?client_id=${CLIENT_ID}&redirect_uri=${REDIRECT_URI}&state=${state}&code_challenge=${codeChallenge}&code_challenge_method=S256`;
  res.redirect(authUrl);
});

// 2. Handle OAuth callback
app.get('/api/oauth/platform/callback', async (req, res) => {
  try {
    const { code, state } = req.query;
    
    // Decrypt and validate state
    const stateData = JSON.parse(decryptState(state));
    const userId = stateData.userId;
    
    // Retrieve PKCE verifier
    const pkceData = sessionPkceStore.get(userId);
    
    // Exchange code for tokens
    const tokenResponse = await axios.post('https://oauth.platform.com/token', {
      grant_type: 'authorization_code',
      code,
      redirect_uri: REDIRECT_URI,
      client_id: CLIENT_ID,
      client_secret: CLIENT_SECRET,
      code_verifier: pkceData.codeVerifier
    });
    
    const { access_token, refresh_token, expires_in } = tokenResponse.data;
    
    // Get user info from platform
    const userInfo = await axios.get('https://api.platform.com/me', {
      headers: { Authorization: `Bearer ${access_token}` }
    });
    
    // Store in database
    const { error } = await supabaseAdmin
      .from('user_accounts')
      .upsert({
        user_id: userId,
        platform: 'platform',
        access_token,
        refresh_token,
        token_expires_at: new Date(Date.now() + expires_in * 1000).toISOString(),
        platform_user_id: userInfo.data.id,
        platform_username: userInfo.data.username,
        status: 'active'
      });
    
    // Redirect to settings
    res.redirect('/dashboard/settings?success=platform');
    
  } catch (error) {
    console.error('OAuth callback error:', error);
    res.redirect('/dashboard/settings?error=oauth_failed');
  }
});
```

#### Multi-Account Posting Pattern
```javascript
// In scheduler.js - always follow this pattern for new platforms
if (platform === 'newplatform') {
  if (credentials.newplatform && Array.isArray(credentials.newplatform)) {
    results.newplatform = [];
    for (const account of credentials.newplatform) {
      try {
        const result = await postToNewPlatform(text, image_url, account);
        results.newplatform.push(result);
        
        if (result.success) {
          console.log(`    âœ… Posted to NewPlatform (${account.platform_username})`);
        } else {
          console.log(`    âŒ NewPlatform error: ${result.error}`);
        }
      } catch (err) {
        console.error(`    âŒ NewPlatform error:`, err.message);
        results.newplatform.push({
          success: false,
          error: err.message,
          platform: 'newplatform'
        });
      }
    }
  }
}
```

### Frontend (React)

#### File Organization
```
dashboard/src/
  â”œâ”€â”€ main.jsx                 # Entry point
  â”œâ”€â”€ App.jsx                  # Routes & navigation
  â”œâ”€â”€ pages/
  â”‚   â”œâ”€â”€ Dashboard.jsx        # Overview
  â”‚   â”œâ”€â”€ CreatePost.jsx       # Post creation
  â”‚   â”œâ”€â”€ Templates.jsx        # Template management
  â”‚   â”œâ”€â”€ Analytics.jsx        # Stats & charts
  â”‚   â”œâ”€â”€ Settings.jsx         # Account connections
  â”‚   â””â”€â”€ Pricing.jsx          # Plan selection
  â”œâ”€â”€ components/
  â”‚   â”œâ”€â”€ ui/                  # Reusable UI components
  â”‚   â”‚   â”œâ”€â”€ LoadingSkeleton.jsx
  â”‚   â”‚   â”œâ”€â”€ ErrorBoundary.jsx
  â”‚   â”‚   â”œâ”€â”€ Toast.jsx
  â”‚   â”‚   â””â”€â”€ EmptyState.jsx
  â”‚   â”œâ”€â”€ ProtectedRoute.jsx
  â”‚   â”œâ”€â”€ UpgradeModal.jsx
  â”‚   â””â”€â”€ BillingSettings.jsx
  â”œâ”€â”€ contexts/
  â”‚   â””â”€â”€ AuthContext.jsx      # Auth state management
  â”œâ”€â”€ hooks/
  â”‚   â””â”€â”€ useLoadingState.js   # Custom hooks
  â”œâ”€â”€ lib/
  â”‚   â”œâ”€â”€ supabase.js          # Supabase client
  â”‚   â””â”€â”€ api.js               # Axios instance
  â””â”€â”€ utils/
      â”œâ”€â”€ animations.js
      â””â”€â”€ errorHandler.js
```

#### Component Structure
```javascript
// Functional component pattern
import { useState, useEffect } from 'react';
import { useAuth } from '../contexts/AuthContext';
import api from '../lib/api';
import LoadingSkeleton from '../components/ui/LoadingSkeleton';
import ErrorMessage from '../components/ui/ErrorMessage';

function ComponentName() {
  // 1. Hooks
  const { user } = useAuth();
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  // 2. Effects
  useEffect(() => {
    fetchData();
  }, []);
  
  // 3. Event handlers
  async function fetchData() {
    try {
      setLoading(true);
      const response = await api.get('/api/endpoint');
      setData(response.data);
    } catch (err) {
      setError(err.response?.data?.error || 'Failed to fetch data');
    } finally {
      setLoading(false);
    }
  }
  
  async function handleAction() {
    try {
      await api.post('/api/action', { data });
      toast.success('Action completed!');
    } catch (err) {
      toast.error(err.response?.data?.error || 'Action failed');
    }
  }
  
  // 4. Early returns for loading/error states
  if (loading) return <LoadingSkeleton />;
  if (error) return <ErrorMessage message={error} />;
  if (!data) return <EmptyState />;
  
  // 5. Main render
  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-2xl font-bold mb-6">Component Title</h1>
      {/* Content */}
    </div>
  );
}

export default ComponentName;
```

#### Tailwind CSS Usage
- Use utility-first approach: `className="flex items-center gap-4 p-6 bg-white rounded-lg shadow"`
- Responsive prefixes: `className="w-full md:w-1/2 lg:w-1/3"`
- State variants: `className="bg-blue-600 hover:bg-blue-700 disabled:opacity-50"`
- Dark mode (if needed): `className="bg-white dark:bg-gray-800"`

#### API Calls
```javascript
// Always use the configured api instance from lib/api.js
import api from '../lib/api';

// GET request
const response = await api.get('/api/endpoint');
const data = response.data;

// POST request
const response = await api.post('/api/endpoint', { 
  key: value 
});

// With query parameters
const response = await api.get('/api/endpoint', {
  params: { filter: 'active', page: 1 }
});

// Error handling
try {
  const response = await api.post('/api/endpoint', data);
  if (response.data.success) {
    toast.success('Success!');
  }
} catch (error) {
  const message = error.response?.data?.error || 'Something went wrong';
  toast.error(message);
}
```

---

## Platform-Specific Guidelines

### LinkedIn
- URN format: `urn:li:person:XXXXX` (personal) or `urn:li:organization:XXXXX` (company)
- Two account types: `person` and `organization`
- Rate limit: 125 posts/day per token
- Image upload: Register â†’ Upload binary â†’ Create post with asset URN

### Twitter/X
- OAuth 1.0a with signature generation
- Rate limit: 300 tweets/3 hours
- Video uploads require Elevated API access
- Media upload separate from tweet creation

### Telegram
- Bot API with token from @BotFather
- Chat ID can be username (@channel) or numeric ID (-100123456789)
- No OAuth needed, just bot token + chat ID

### Instagram/Facebook
- Same OAuth flow (Facebook Graph API)
- Pending app review for `pages_read_engagement` permission
- Instagram requires image (no text-only posts)
- Facebook posts to Pages, not personal profiles

### YouTube
- OAuth 2.0 with PKCE
- Access tokens expire in 1 hour â†’ implement proactive refresh
- Only video uploads supported (no Community Posts via API)
- Quota: 10,000 units/day (video upload = 1,600 units)

### TikTok
- OAuth 2.0 with scopes: `video.upload`, `video.publish`
- Requires video (no images/text)
- Access tokens expire in 24 hours

---

## Database Schema Reference

### Key Tables
```sql
posts (
  id, user_id, text, image_url, platforms[], 
  status, schedule_time, posted_at, results JSONB
)

user_accounts (
  id, user_id, platform, access_token, refresh_token,
  token_expires_at, platform_user_id, platform_username, status
)

subscriptions (
  user_id, stripe_customer_id, plan, status, current_period_end
)

usage (
  user_id, month, posts_count, ai_count, accounts_count
)

post_templates (
  id, user_id, name, content, category, tags[], is_favorite, use_count
)
```

### RLS Policies
- All queries automatically filter by `user_id = auth.uid()`
- Use `supabaseAdmin` to bypass RLS when needed

---

## Error Handling

### Backend Error Responses
```javascript
// Standard error format
res.status(statusCode).json({
  success: false,
  error: 'Human-readable error message',
  ...(details && { details })
});

// Usage limit error
res.status(402).json({
  success: false,
  error: 'Post limit reached. Upgrade to continue.',
  limitReached: true,
  upgradePlan: 'pro'
});
```

### Frontend Error Display
```javascript
// Use toast notifications for transient errors
toast.error('Failed to connect account. Please try again.');

// Use ErrorMessage component for persistent errors
<ErrorMessage message={error} />

// Use EmptyState for no data scenarios
<EmptyState 
  icon="ðŸ“"
  title="No posts yet"
  description="Create your first post to get started"
  action={<button onClick={goToCreate}>Create Post</button>}
/>
```

---

## Testing & Debugging

### Console Logging Standards
```javascript
// Use emoji prefixes for visibility
console.log('âœ… Success:', message);
console.log('âš ï¸  Warning:', message);
console.error('âŒ Error:', message);
console.log('ðŸ” Debug:', message);
console.log('ðŸ“¤ Posting to:', platforms.join(', '));

// Log full objects with JSON.stringify for better readability
console.log('ðŸ“Š Response:', JSON.stringify(response, null, 2));

// Production: Minimize console output
if (process.env.NODE_ENV === 'production') {
  // Only log errors and critical events
}
```

### Environment-Specific Behavior
```javascript
// Development
if (process.env.NODE_ENV !== 'production') {
  console.log('ðŸ”§ Dev mode: Detailed logging enabled');
  // Include stack traces
  // Enable debug features
}

// Production
if (process.env.NODE_ENV === 'production') {
  // Minimal logging
  // Use error tracking service
  // Enable caching
}
```

---

## Performance Optimization

### Database Queries
- Use indexes on frequently queried columns
- Limit result sets with `.limit()`
- Use `.select()` to fetch only needed columns
- Avoid N+1 queries with eager loading

### API Efficiency
- Implement pagination for large datasets
- Cache frequently accessed data
- Use connection pooling (Supabase handles this)
- Batch operations when possible

### Frontend Performance
- Use React.memo for components with stable props
- Implement lazy loading: `const Component = lazy(() => import('./Component'))`
- Optimize images with Cloudinary transformations
- Use Suspense with fallback for code splitting

---

## Common Tasks & Patterns

### Adding a New Platform

1. **Create service file**: `services/newplatform.js`
   - Implement `postToNewPlatform(text, imageUrl, credentials)`
   - Add token refresh logic if needed
   - Return standardized result object

2. **Add OAuth routes in server.js**:
   - GET `/api/oauth/newplatform/authorize` - Initiate OAuth
   - GET `/api/oauth/newplatform/callback` - Handle callback
   - POST `/api/oauth/newplatform/disconnect` - Disconnect account

3. **Update scheduler.js**:
   - Add platform case in `postNow()` function
   - Follow multi-account posting pattern
   - Handle platform-specific requirements (e.g., video-only)

4. **Update frontend Settings.jsx**:
   - Add "Connect NewPlatform" button
   - Add platform to connected accounts list
   - Handle OAuth redirect flow

5. **Update CreatePost.jsx**:
   - Add platform checkbox
   - Add any platform-specific warnings
   - Update validation logic

6. **Update database migration**:
   - Add platform to CHECK constraint if needed
   - Add to platform enum in user_accounts table

### Implementing a New Feature

1. **Plan before coding**: Write pseudocode or outline
2. **Check existing patterns**: Look for similar features
3. **Backend first**: Implement API endpoint
4. **Frontend integration**: Add UI and connect to API
5. **Test thoroughly**: Test all edge cases
6. **Update documentation**: Add comments and update README

---

## Response Style

### When Writing Code
- Provide complete, working code (no placeholders or TODOs)
- Include proper error handling
- Add comments for complex logic
- Follow the exact patterns shown in this file

### When Explaining
- Be concise but thorough
- Use bullet points for clarity
- Include code examples when helpful
- Reference existing files: "See `services/linkedin.js` for similar pattern"

### When Fixing Bugs
- First understand the problem fully
- Identify root cause, not just symptoms
- Propose minimal, safe fix
- Explain potential side effects

### When Unclear
- Ask specific clarifying questions
- Suggest alternatives
- Explain trade-offs

---

## Critical Reminders

1. **NEVER break existing OAuth flows** - they're complex and working
2. **ALWAYS test platform integrations** with actual accounts
3. **RESPECT rate limits** - implement proper delays and retries
4. **PROTECT user data** - never log sensitive tokens
5. **MAINTAIN multi-account support** - users can have multiple accounts per platform
6. **IMPLEMENT proper token refresh** - prevent auth failures
7. **USE RLS correctly** - understand when to use admin vs regular client
8. **FOLLOW the scheduler pattern** - it's the core of the app
9. **KEEP responses consistent** - return same structure across endpoints
10. **DOCUMENT breaking changes** - always explain impacts

---

## Deployment & Production Safety

### Pre-Deployment Checklist

**CRITICAL: Follow this checklist for EVERY deployment to avoid production failures!**

#### 1. When Deleting Files

```bash
# NEVER just delete a file - ALWAYS follow this process:
# Step 1: Identify the file to delete
rm services/oldfile.js

# Step 2: Search for ALL imports/references
grep -r "oldfile" .
grep -r "require.*oldfile" .
grep -r "import.*oldfile" .

# Step 3: Remove ALL imports in files that used it
# Edit server.js, scheduler.js, or any file that imported it

# Step 4: Remove ALL function calls
# Search for functions exported from deleted file
grep -r "functionName" .

# Step 5: Remove/comment out routes that used it
# Check server.js for any endpoints using the deleted functions

# Step 6: Verify syntax
node -c server.js
node -c services/*.js

# Step 7: Test locally (if possible)
node server.js  # Should start without errors

# Step 8: Commit & push
git add -A
git commit -m "Remove oldfile and all references"
git push
```

**Real Example from Production Issue:**
```javascript
// âŒ MISTAKE: Deleted services/youtube-transcript.js
// BUT forgot to remove:
// - require('./services/youtube-transcript') in server.js (line 33-36)
// - app.post('/api/ai/youtube-caption') route (line 1097-1158)
// Result: MODULE_NOT_FOUND error on Railway

// âœ… CORRECT: Delete file + remove all references in one commit
```

#### 2. When Creating New Files with Dependencies

```bash
# ALWAYS follow this checklist when creating new service files:

# Step 1: Write the code
# Create services/newfeature.js

# Step 2: Install required packages
npm install package-name

# Step 3: VERIFY package.json was updated!
git diff package.json  # Should show the new dependency

# Step 4: Check syntax
node -c services/newfeature.js
node -c server.js

# Step 5: Commit BOTH code AND package.json
git add services/newfeature.js package.json
git commit -m "Add new feature with required dependencies"

# Step 6: Push
git push origin main
```

**Real Example from Production Issue:**
```javascript
// âŒ MISTAKE: Created services/youtube-transcript.js
// Used: const Anthropic = require('@anthropic-ai/sdk')
// BUT package.json didn't have @anthropic-ai/sdk!
// Result: Error: Cannot find module '@anthropic-ai/sdk'

// âœ… CORRECT: npm install @anthropic-ai/sdk
// Then verify package.json includes it before pushing
```

#### 3. ESM vs CommonJS Module Handling

```javascript
// PROBLEM: Some npm packages are ES Modules (ESM)
// Our project uses CommonJS (require/module.exports)
// Can't use require() for ES Modules!

// âŒ WRONG (causes ERR_REQUIRE_ESM):
const youtubei = require('youtubei.js');  // youtubei.js is ESM!

// âœ… CORRECT (use dynamic import):
async function extractTranscript(url) {
  const { Innertube } = await import('youtubei.js');  // Dynamic import!
  const youtube = await Innertube.create();
  // ... rest of code
}

// Rule: If you see ERR_REQUIRE_ESM, convert to dynamic import()
```

#### 4. Consistency in Configuration

```javascript
// ALWAYS use the same configuration across ALL files

// âŒ WRONG: Different model names in different files
// File 1: model: 'claude-3-5-sonnet-20241022'  (doesn't exist)
// File 2: model: 'claude-sonnet-4-20250514'     (works)
// Result: 404 not_found_error

// âœ… CORRECT: Search existing files for working config
grep -r "model:" services/
// Then use the SAME model name everywhere
```

**Checklist Before Creating New Files:**
- [ ] Check what other files use (API endpoints, model names, etc.)
- [ ] Use the SAME configuration
- [ ] Don't guess - copy working patterns

#### 5. Local Syntax Validation

```bash
# BEFORE every git push, run these checks:

# Check syntax of modified files
node -c server.js
node -c services/newfile.js

# Try to start server (will catch import errors)
# Kill after 3 seconds with Ctrl+C
node server.js

# If it starts without errors, you're good to push!
```

#### 6. Complete Deployment Workflow

```bash
# MANDATORY workflow for every feature/fix:

# 1. Make changes locally
vim services/feature.js

# 2. Install any new dependencies
npm install new-package

# 3. Search for any references if deleting/modifying
grep -r "oldFunction" .

# 4. Update all related files
vim server.js scheduler.js  # Add imports, routes, etc.

# 5. Verify package.json has all dependencies
cat package.json | grep new-package

# 6. Check syntax
node -c server.js
node -c services/*.js

# 7. Verify no linter errors (if applicable)
npm run lint 2>/dev/null || true

# 8. Commit with descriptive message
git add -A
git commit -m "Add feature: description of changes"

# 9. Push to production
git push origin main

# 10. Watch Railway deployment logs
# If errors appear, fix immediately using this checklist again
```

### Common Deployment Errors & Fixes

| Error | Cause | Fix |
|-------|-------|-----|
| `MODULE_NOT_FOUND` | Deleted file still imported | Remove all require() statements |
| `Cannot find module '@pkg'` | package.json missing dependency | `npm install @pkg` + commit package.json |
| `ERR_REQUIRE_ESM` | Using require() for ES Module | Change to `await import()` |
| `404 not_found_error` (API) | Wrong endpoint/model name | Check working files, use same config |
| `ReferenceError: X is not defined` | Function deleted but still called | Remove all function calls |

### Railway-Specific Notes

```bash
# Railway deploys in this order:
1. git pull          # Gets your code
2. npm install       # Reads package.json
3. npm run build     # Builds dashboard
4. node server.js    # Starts server
5. Health check      # Hits /api/health

# If ANY step fails, deployment fails!
# Health check timeout = 5 minutes of retries

# Fix deployment failures:
# 1. Check Railway logs (NOT GitHub)
# 2. Find the exact error
# 3. Fix locally with checklist above
# 4. Push fix
# 5. Wait 2-3 minutes for new deployment
```

### Emergency Rollback

```bash
# If production is broken and you need to rollback:

# Option 1: Revert last commit
git revert HEAD
git push origin main

# Option 2: Reset to last working commit
git reset --hard <commit-hash>
git push --force origin main  # Only in emergencies!

# Option 3: Railway dashboard
# Go to deployments â†’ Redeploy previous successful build
```

---

## When in Doubt

- Check similar files in the codebase for patterns
- Ask before making structural changes
- Prefer extending over modifying
- Test with real API calls when possible
- Verify database changes won't break RLS
- Consider edge cases (token expiry, rate limits, missing data)
- **ALWAYS follow the deployment checklist above before pushing**

---

**This project is production-ready with real users. Changes must be safe, tested, and maintainable.**