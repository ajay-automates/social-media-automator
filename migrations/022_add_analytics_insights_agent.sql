-- Analytics Insights Agent Database Schema
-- Add tables for AI-powered analytics insights and recommendations

-- ============================================================
-- 1. ANALYTICS INSIGHTS TABLE
-- ============================================================
-- Stores AI-generated insights about posting patterns and performance
CREATE TABLE IF NOT EXISTS analytics_insights (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,

  -- Insight metadata
  insight_type VARCHAR(50) NOT NULL CHECK (insight_type IN (
    'best_time', 'best_day', 'content_type', 'caption_length',
    'hashtag_performance', 'platform_performance', 'emoji_usage',
    'question_performance', 'cta_effectiveness', 'overall_trend'
  )),

  -- Insight details
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  impact_score INTEGER CHECK (impact_score BETWEEN 0 AND 100), -- How impactful this insight is
  confidence_score INTEGER CHECK (confidence_score BETWEEN 0 AND 100), -- AI confidence in this insight

  -- Data backing the insight
  data_points INTEGER NOT NULL, -- Number of posts analyzed
  metric_value DECIMAL, -- The key metric (e.g., 40% better engagement)
  comparison_value DECIMAL, -- Baseline for comparison

  -- Actionable recommendation
  recommendation TEXT NOT NULL,
  category VARCHAR(20) CHECK (category IN ('positive', 'negative', 'neutral')),

  -- Metadata
  analysis_period_start TIMESTAMPTZ NOT NULL,
  analysis_period_end TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ, -- Insights become stale over time
  is_active BOOLEAN DEFAULT true,

  -- Track if user has seen/acted on it
  viewed_at TIMESTAMPTZ,
  dismissed_at TIMESTAMPTZ
);

CREATE INDEX idx_insights_user_id ON analytics_insights(user_id);
CREATE INDEX idx_insights_type ON analytics_insights(insight_type);
CREATE INDEX idx_insights_active ON analytics_insights(is_active) WHERE is_active = true;
CREATE INDEX idx_insights_created ON analytics_insights(created_at DESC);

-- ============================================================
-- 2. CONTENT PATTERNS TABLE
-- ============================================================
-- Stores detected patterns in user's content for ML/pattern recognition
CREATE TABLE IF NOT EXISTS content_patterns (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,

  -- Pattern identification
  pattern_type VARCHAR(50) NOT NULL CHECK (pattern_type IN (
    'time_slot', 'day_of_week', 'content_format', 'caption_style',
    'hashtag_strategy', 'emoji_frequency', 'post_length', 'media_type'
  )),
  pattern_key TEXT NOT NULL, -- e.g., "monday_9am", "question_post", "long_caption"

  -- Performance metrics
  total_posts INTEGER NOT NULL DEFAULT 0,
  total_success INTEGER NOT NULL DEFAULT 0,
  success_rate DECIMAL(5,2),
  avg_engagement_score DECIMAL(5,2), -- 0-100 score

  -- Statistical data
  best_performing_post_id BIGINT REFERENCES posts(id) ON DELETE SET NULL,
  worst_performing_post_id BIGINT REFERENCES posts(id) ON DELETE SET NULL,

  -- Pattern characteristics
  characteristics JSONB, -- Store additional pattern-specific data

  -- Timestamps
  first_detected TIMESTAMPTZ DEFAULT NOW(),
  last_updated TIMESTAMPTZ DEFAULT NOW(),
  last_post_analyzed TIMESTAMPTZ
);

CREATE INDEX idx_patterns_user_id ON content_patterns(user_id);
CREATE INDEX idx_patterns_type ON content_patterns(pattern_type);
CREATE INDEX idx_patterns_success_rate ON content_patterns(success_rate DESC);
CREATE UNIQUE INDEX idx_patterns_user_type_key ON content_patterns(user_id, pattern_type, pattern_key);

-- ============================================================
-- 3. INSIGHT RECOMMENDATIONS TABLE
-- ============================================================
-- Stores specific actionable recommendations generated by the AI
CREATE TABLE IF NOT EXISTS insight_recommendations (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  insight_id BIGINT REFERENCES analytics_insights(id) ON DELETE CASCADE,

  -- Recommendation details
  recommendation_type VARCHAR(50) NOT NULL CHECK (recommendation_type IN (
    'schedule_optimization', 'content_improvement', 'platform_strategy',
    'hashtag_optimization', 'caption_style', 'engagement_tactic'
  )),

  title TEXT NOT NULL,
  description TEXT NOT NULL,
  action_items TEXT[], -- Array of specific actions to take

  -- Priority and impact
  priority VARCHAR(20) CHECK (priority IN ('low', 'medium', 'high', 'critical')),
  expected_impact_percentage INTEGER CHECK (expected_impact_percentage BETWEEN 0 AND 200),

  -- Implementation tracking
  status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'applied', 'dismissed', 'testing')),
  applied_at TIMESTAMPTZ,
  results JSONB, -- Track results if user applies recommendation

  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ
);

CREATE INDEX idx_recommendations_user_id ON insight_recommendations(user_id);
CREATE INDEX idx_recommendations_status ON insight_recommendations(status);
CREATE INDEX idx_recommendations_priority ON insight_recommendations(priority);
CREATE INDEX idx_recommendations_created ON insight_recommendations(created_at DESC);

-- ============================================================
-- 4. DRAFT POST SCORES TABLE
-- ============================================================
-- Stores AI scores for draft posts (predictive scoring)
CREATE TABLE IF NOT EXISTS draft_post_scores (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  post_id BIGINT REFERENCES posts(id) ON DELETE CASCADE, -- NULL if just a draft

  -- Draft content (before posting)
  draft_caption TEXT NOT NULL,
  draft_platforms TEXT[],
  draft_has_image BOOLEAN DEFAULT false,
  draft_has_video BOOLEAN DEFAULT false,
  draft_hashtag_count INTEGER DEFAULT 0,

  -- AI-generated scores
  overall_score INTEGER CHECK (overall_score BETWEEN 0 AND 100),
  engagement_prediction INTEGER CHECK (engagement_prediction BETWEEN 0 AND 100),
  virality_score INTEGER CHECK (virality_score BETWEEN 0 AND 100),

  -- Platform-specific scores
  platform_scores JSONB, -- { "linkedin": 85, "twitter": 72, ... }

  -- Detailed analysis
  strengths TEXT[],
  weaknesses TEXT[],
  suggestions TEXT[],

  -- Comparison to user's best posts
  compared_to_best DECIMAL(5,2), -- % compared to user's top 10% posts
  compared_to_avg DECIMAL(5,2), -- % compared to user's average

  -- Metadata
  scored_at TIMESTAMPTZ DEFAULT NOW(),
  model_version VARCHAR(50) -- Track which AI model version scored it
);

CREATE INDEX idx_draft_scores_user_id ON draft_post_scores(user_id);
CREATE INDEX idx_draft_scores_post_id ON draft_post_scores(post_id);
CREATE INDEX idx_draft_scores_overall ON draft_post_scores(overall_score DESC);
CREATE INDEX idx_draft_scores_created ON draft_post_scores(scored_at DESC);

-- ============================================================
-- 5. WEEKLY INSIGHTS SUMMARY TABLE
-- ============================================================
-- Aggregated weekly summaries for email digests/dashboard
CREATE TABLE IF NOT EXISTS weekly_insights_summary (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,

  -- Week information
  week_start TIMESTAMPTZ NOT NULL,
  week_end TIMESTAMPTZ NOT NULL,

  -- Post statistics
  total_posts INTEGER NOT NULL,
  successful_posts INTEGER NOT NULL,
  failed_posts INTEGER NOT NULL,
  success_rate DECIMAL(5,2),

  -- Key insights (top 5)
  top_insights JSONB, -- Array of insight summaries

  -- Performance compared to previous week
  performance_trend VARCHAR(20) CHECK (performance_trend IN ('improving', 'declining', 'stable')),
  performance_change_pct DECIMAL(5,2),

  -- Key recommendations
  top_recommendations TEXT[],

  -- AI-generated summary
  executive_summary TEXT,

  -- Metadata
  generated_at TIMESTAMPTZ DEFAULT NOW(),
  sent_email BOOLEAN DEFAULT false,
  email_sent_at TIMESTAMPTZ
);

CREATE INDEX idx_weekly_summary_user_id ON weekly_insights_summary(user_id);
CREATE INDEX idx_weekly_summary_week ON weekly_insights_summary(week_start DESC);
CREATE UNIQUE INDEX idx_weekly_summary_user_week ON weekly_insights_summary(user_id, week_start);

-- ============================================================
-- 6. HELPER VIEWS FOR ANALYTICS
-- ============================================================

-- View: Post performance by time slot
CREATE OR REPLACE VIEW post_performance_by_time AS
SELECT
  p.id,
  EXTRACT(DOW FROM p.posted_at) as day_of_week,
  EXTRACT(HOUR FROM p.posted_at) as hour_of_day,
  p.status,
  pa.platform,
  pa.success,
  p.posted_at
FROM posts p
LEFT JOIN post_analytics pa ON p.id = pa.post_id
WHERE p.posted_at IS NOT NULL;

-- View: Active insights for users
CREATE OR REPLACE VIEW active_user_insights AS
SELECT
  ai.*,
  CASE
    WHEN ai.category = 'positive' THEN 1
    WHEN ai.category = 'neutral' THEN 2
    ELSE 3
  END as priority_order
FROM analytics_insights ai
WHERE ai.is_active = true
  AND (ai.expires_at IS NULL OR ai.expires_at > NOW())
  AND ai.dismissed_at IS NULL
ORDER BY ai.impact_score DESC, ai.confidence_score DESC;

-- ============================================================
-- 7. ROW LEVEL SECURITY (RLS)
-- ============================================================

-- Enable RLS on all tables
ALTER TABLE analytics_insights ENABLE ROW LEVEL SECURITY;
ALTER TABLE content_patterns ENABLE ROW LEVEL SECURITY;
ALTER TABLE insight_recommendations ENABLE ROW LEVEL SECURITY;
ALTER TABLE draft_post_scores ENABLE ROW LEVEL SECURITY;
ALTER TABLE weekly_insights_summary ENABLE ROW LEVEL SECURITY;

-- Policies: Users can only see their own data
CREATE POLICY "Users can view own insights" ON analytics_insights
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own insights" ON analytics_insights
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own insights" ON analytics_insights
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can view own patterns" ON content_patterns
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own patterns" ON content_patterns
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own patterns" ON content_patterns
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can view own recommendations" ON insight_recommendations
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own recommendations" ON insight_recommendations
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own recommendations" ON insight_recommendations
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can view own draft scores" ON draft_post_scores
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own draft scores" ON draft_post_scores
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can view own weekly summaries" ON weekly_insights_summary
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own weekly summaries" ON weekly_insights_summary
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- ============================================================
-- 8. FUNCTIONS FOR COMMON QUERIES
-- ============================================================

-- Function: Get user's best performing time slots
CREATE OR REPLACE FUNCTION get_best_posting_times(p_user_id UUID, p_platform TEXT DEFAULT NULL, p_limit INTEGER DEFAULT 5)
RETURNS TABLE (
  day_of_week INTEGER,
  hour_of_day INTEGER,
  success_rate DECIMAL,
  total_posts INTEGER,
  recommendation TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    EXTRACT(DOW FROM p.posted_at)::INTEGER as day_of_week,
    EXTRACT(HOUR FROM p.posted_at)::INTEGER as hour_of_day,
    ROUND(AVG(CASE WHEN pa.success THEN 1 ELSE 0 END) * 100, 2) as success_rate,
    COUNT(*)::INTEGER as total_posts,
    CASE EXTRACT(DOW FROM p.posted_at)::INTEGER
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      ELSE 'Saturday'
    END || ' at ' || EXTRACT(HOUR FROM p.posted_at)::TEXT || ':00' as recommendation
  FROM posts p
  JOIN post_analytics pa ON p.id = pa.post_id
  WHERE p.user_id = p_user_id
    AND p.posted_at IS NOT NULL
    AND (p_platform IS NULL OR pa.platform = p_platform)
  GROUP BY EXTRACT(DOW FROM p.posted_at), EXTRACT(HOUR FROM p.posted_at)
  HAVING COUNT(*) >= 3  -- At least 3 posts in this time slot
  ORDER BY success_rate DESC, total_posts DESC
  LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- ============================================================
-- MIGRATION COMPLETE
-- ============================================================

COMMENT ON TABLE analytics_insights IS 'AI-generated insights about user posting patterns and performance';
COMMENT ON TABLE content_patterns IS 'Detected patterns in user content for ML and recommendations';
COMMENT ON TABLE insight_recommendations IS 'Actionable recommendations generated by analytics agent';
COMMENT ON TABLE draft_post_scores IS 'Predictive scores for draft posts before publishing';
COMMENT ON TABLE weekly_insights_summary IS 'Weekly aggregated insights for email digests';
